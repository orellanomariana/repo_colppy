# -*- coding: utf-8 -*-
"""colppy_baja_diario_v02_para_google_drive_credenciales.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jKp4kJ-dC-kPU_PsTXkgDhXnLy2FxlM9
"""

import requests
import hashlib
import json
import pandas as pd
!pip install --upgrade gspread pandas gspread_dataframe

import gspread
from google.oauth2.service_account import Credentials

SCOPES = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

creds = Credentials.from_service_account_file("credentials.json", scopes=SCOPES)
gc = gspread.authorize(creds)

# URL de la API
URL = "https://login.colppy.com/lib/frontera2/service.php"

# Credenciales de autenticación (usuario de desarrollador en MD5)
auth_payload = {
    "auth": {
        "usuario": "orellano.mariana@gmail.com",  # Usuario de desarrollador
        "password": "a4a0988e0b0c94919be83a6effd1a8bd"  # Contraseña en formato MD5
    },
    "service": {
        "provision": "Usuario",
        "operacion": "iniciar_sesion"
    },
    "parameters": {
        "usuario": "Atacyc@atacyc.com.ar",  # Usuario de Colppy
        "password": "bff7653336974f35a40aa9e06fbab150"  # Contraseña en formato MD5
    }
}

# Solicitar clave de sesión
response = requests.post(URL, json=auth_payload, headers={"Content-Type": "application/json"})
session_data = response.json()

# Verificar si la autenticación fue exitosa
if session_data["response"]["success"]:
    clave_sesion = session_data["response"]["data"]["claveSesion"]
    print(f"Clave de sesión obtenida: {clave_sesion}")

clave_sesion

# Define los datos de la solicitud
movimientos_payload = {
    "auth": {
        "usuario": "orellano.mariana@gmail.com",  # Usuario API
        "password": "a4a0988e0b0c94919be83a6effd1a8bd"  # Contraseña en MD5
    },
    "service": {
        "provision": "Contabilidad",
        "operacion": "listar_movimientosdiario"
    },
    "parameters": {
        "sesion": {
            "usuario": "Atacyc@atacyc.com.ar",  # Usuario de la empresa
            "claveSesion": clave_sesion  # Clave de sesión obtenida previamente
        },
        "idEmpresa": "89021",
        "fromDate": "2025-01-01",
        "toDate": "2025-12-31",
        "start": 0,
        "limit": 1000
    }
}

# Enviar la solicitud
response = requests.post(URL, json=movimientos_payload, headers={"Content-Type": "application/json"})

# Convertir la respuesta a JSON
movimientos_data = response.json()

# Verificar si la solicitud fue exitosa
if movimientos_data.get("response", {}).get("success"):
    print("Movimientos obtenidos correctamente:")
    print(json.dumps(movimientos_data, indent=4, ensure_ascii=False))
else:
    print(f"Error al obtener movimientos: {movimientos_data.get('response', {}).get('message', 'Error desconocido')}")

print(json.dumps(movimientos_data, indent=4, ensure_ascii=False))

# Verifica si "response" y "movimientos" existen en la respuesta
if "response" in movimientos_data and "movimientos" in movimientos_data["response"]:
    df = pd.DataFrame(movimientos_data["response"]["movimientos"])
    print(df.head())  # Muestra los primeros registros
else:
    print("No se encontraron movimientos en la respuesta.")

df

df.shape

# Filtrar solo cuentas cuyo idPlanCuenta comienza con "4" o "5"
df_filtrado = df[df["idPlanCuenta"].astype(str).str.startswith(("1", "2", "3", "4", "5"))]

# Mostrar resultado
df_filtrado

df_filtrado.columns

df_filtrado_columnas = df_filtrado[["fechaContable", "idPlanCuenta", "DebitoCredito", "Importe",'idElementoContacto', "idObjetoContacto"]]
df_filtrado_columnas # defino columnas que quiero ver

df_filtrado_columnas['Importe'] = pd.to_numeric(df_filtrado_columnas['Importe'], errors='coerce')
df_filtrado_columnas['Importe'] = df_filtrado_columnas['Importe'].apply(lambda x: int(x) if x == int(x) else x)
df_filtrado_columnas

# Reemplazar valores NaN o None por 0 en la columna 'idElementoContacto'
df_filtrado_columnas['idElementoContacto'] = df_filtrado_columnas['idElementoContacto'].fillna(0).astype(int)

# convierto a int
df_filtrado_columnas["idElementoContacto"] = df_filtrado_columnas["idElementoContacto"].astype(int)

# Reemplazar valores NaN o None por 0 en la columna 'idElementoContacto'
df_filtrado_columnas['idObjetoContacto'] = df_filtrado_columnas['idObjetoContacto'].fillna(0).astype(int)

df_filtrado_columnas["idObjetoContacto"] = df_filtrado_columnas["idObjetoContacto"].astype(int)

id_clientes_unicos = df_filtrado_columnas[df_filtrado_columnas["idElementoContacto"] == 18]["idObjetoContacto"].unique()
id_clientes_unicos  # Verifica si devuelve valores

id_proveedores_unicos = df_filtrado_columnas[df_filtrado_columnas["idElementoContacto"] == 3]["idObjetoContacto"].unique()
id_proveedores_unicos  # Verifica si devuelve valores

# ID del cliente a consultar (ajusta este valor)
id_cliente = 11419734

# Función para obtener los detalles del cliente
def leer_detalle_cliente(id_cliente):
    data = {
        "auth": {
            "usuario": "orellano.mariana@gmail.com",
            "password": "a4a0988e0b0c94919be83a6effd1a8bd"
        },
        "service": {
            "provision": "Cliente",
            "operacion": "leer_detalle_cliente"
        },
        "parameters": {
            "sesion": {
                "usuario": "Atacyc@atacyc.com.ar",
                "claveSesion": clave_sesion  # Usa la clave de sesión válida
            },
            "idEmpresa": "89021",
            "idCliente": str(id_cliente)  # Convertir a string por seguridad
        }
    }

    response = requests.post(URL, json=data, headers={"Content-Type": "application/json"})
    return response.json()

# Ejecutar la petición para el cliente especificado
detalle_cliente = leer_detalle_cliente(id_cliente)

# Mostrar resultado
print(json.dumps(detalle_cliente, indent=4, ensure_ascii=False))

# ID del proveedor a consultar (ajusta este valor)
id_proveedor = 3752925

# Función para obtener los detalles del cliente
def leer_detalle_proveedor(id_proveedor):
    data = {
        "auth": {
            "usuario": "orellano.mariana@gmail.com",
            "password": "a4a0988e0b0c94919be83a6effd1a8bd"
        },
        "service": {
            "provision": "Proveedor",
            "operacion": "leer_proveedor"
        },
        "parameters": {
            "sesion": {
                "usuario": "Atacyc@atacyc.com.ar",
                "claveSesion": clave_sesion  # Usa la clave de sesión válida
            },
            "idProveedor": str(id_proveedor),  # Convertir a string por seguridad
            "idEmpresa": "89021"

        }
    }

    response = requests.post(URL, json=data, headers={"Content-Type": "application/json"})
    return response.json()

# Ejecutar la petición para el proveedor especificado
detalle_proveedor = leer_detalle_proveedor(id_proveedor)

# Mostrar resultado
print(json.dumps(detalle_proveedor, indent=4, ensure_ascii=False))

# Lista para almacenar los resultados
clientes_data = []

# Iterar sobre cada id_cliente único
for id_cliente in id_clientes_unicos:
    print(f"Consultando API con ID: {id_cliente}")  # Imprimir el ID que estamos consultando
    detalle_cliente = leer_detalle_cliente(id_cliente)

    # Verificar la respuesta completa de la API
    print(f"Respuesta de la API para ID {id_cliente}:")
    print(json.dumps(detalle_cliente, indent=4, ensure_ascii=False))  # Imprimir respuesta completa

    # Acceder a la RazonSocial dentro de la respuesta
    try:
        razon_social = detalle_cliente.get("response", {}).get("data", {}).get("RazonSocial", None)
    except KeyError:
        razon_social = None

    # Agregar los resultados a la lista como un diccionario
    clientes_data.append({"idObjetoContacto": id_cliente, "RazonSocial": razon_social})

# Convertir la lista de diccionarios a un DataFrame
df_clientes = pd.DataFrame(clientes_data)

df_clientes

# Lista para almacenar los resultados
proveedores_data = []

# Iterar sobre cada id_proveedor único
for id_proveedor in id_proveedores_unicos:
    print(f"Consultando API con ID: {id_proveedor}")  # Imprimir el ID que estamos consultando
    detalle_proveedor = leer_detalle_proveedor(id_proveedor)

    # Verificar la respuesta completa de la API
    print(f"Respuesta de la API para ID {id_proveedor}:")
    print(json.dumps(detalle_proveedor, indent=4, ensure_ascii=False))  # Imprimir respuesta completa

    # Acceder a la RazonSocial dentro de la respuesta
    try:
        # Asegurándonos de acceder correctamente a 'detalle' dentro de 'response'
        razon_social = detalle_proveedor.get("response", {}).get("detalle", {}).get("RazonSocial", None)

        # Depurar: Verificar qué estamos extrayendo
        print(f"RazonSocial extraída para ID {id_proveedor}: {razon_social}")
    except KeyError as e:
        print(f"Error al acceder a 'RazonSocial' para ID {id_proveedor}: {e}")
        razon_social = None

    # Agregar los resultados a la lista como un diccionario
    proveedores_data.append({"idObjetoContacto": id_proveedor, "RazonSocial": razon_social})

# Convertir la lista de diccionarios a un DataFrame
df_proveedores = pd.DataFrame(proveedores_data)

# Mostrar el DataFrame resultante
print(df_proveedores)

df_proveedores

# Convertir las columnas idObjetoContacto a tipo int64 en los tres DataFrames
df_filtrado_columnas['idObjetoContacto'] = df_filtrado_columnas['idObjetoContacto'].astype(int)
df_clientes['idObjetoContacto'] = df_clientes['idObjetoContacto'].astype(int)
df_proveedores['idObjetoContacto'] = df_proveedores['idObjetoContacto'].astype(int)

# Realizar el merge entre df_filtrado_columnas, df_clientes y df_proveedores
df_final = pd.merge(df_filtrado_columnas, df_clientes, on='idObjetoContacto', how='left')
df_final = pd.merge(df_final, df_proveedores, on='idObjetoContacto', how='left')

# Mostrar el DataFrame resultante
df_final

# Combinar las dos columnas 'RazonSocial_x' y 'RazonSocial_y'
df_final['RazonSocial'] = df_final['RazonSocial_x'].fillna(df_final['RazonSocial_y'])

# Eliminar las columnas separadas si ya no las necesitas
df_final = df_final.drop(['RazonSocial_x', 'RazonSocial_y'], axis=1)
df_final = df_final.drop(['idElementoContacto', 'idObjetoContacto'], axis=1)

df_final

# Contar cuántos valores NaN hay en la columna 'RazonSocial'
nan_count = df_final['RazonSocial'].isna().sum()

print(f"Cantidad de valores NaN en la columna 'RazonSocial': {nan_count}")

# Filtrar las filas que tienen al menos un NaN en alguna columna
df_with_nan = df_final[df_final.isna().any(axis=1)]

# Mostrar las filas con NaN
df_with_nan

"""

*   5.1.026.000.00.0  Seguros
*   5.1.002.000.00.0  sueldos e indemnizaciones
*   5.1.003.000.00.0  Cargas sociales
*   5.1.005.000.00.0  Seguro de vida
*   5.1.033.000.00.0  Comisiones y gastos bancarios
*   4.1.004.000.00.0  Intereses ganados
*   5.1.017.000.00.0  Licencias Microsoft




"""

#listar plan de cuentas


# Autenticación
usuario_api = "orellano.mariana@gmail.com"
password_api = "a4a0988e0b0c94919be83a6effd1a8bd"
usuario_empresa = "Atacyc@atacyc.com.ar"
clave_sesion_empresa = clave_sesion  # Reemplaza con la clave de sesión válida
id_empresa = "89021"

# Encriptar la contraseña en MD5
password_md5 = hashlib.md5(password_api.encode('utf-8')).hexdigest()

# Crear los datos del cuerpo de la solicitud
data = {
    "auth": {
        "usuario": usuario_api,
        "password": password_api
    },
    "service": {
        "provision": "Contabilidad",
        "operacion": "listar_cuentasdiario"
    },
    "parameters": {
        "sesion": {
            "usuario": usuario_empresa,
            "claveSesion": clave_sesion        },
        "idEmpresa": id_empresa,
        "query": ""
    }
}

# URL de la API
URL = "https://login.colppy.com/lib/frontera2/service.php"

# Enviar la solicitud POST
response = requests.post(URL, json=data)

# Verificar el estado de la solicitud y manejar la respuesta
if response.status_code == 200:
    # Convertir la respuesta a formato JSON
    resultado = response.json()
    # Imprimir el resultado
    print(json.dumps(resultado, indent=4, ensure_ascii=False))
else:
    print(f"Error al hacer la solicitud: {response.status_code}")

# Guardar la respuesta de la API en un archivo JSON
with open("respuesta_colppy.json", "w", encoding="utf-8") as json_file:
    json.dump(resultado, json_file, ensure_ascii=False, indent=4)

# Cargar el archivo JSON
with open("respuesta_colppy.json", "r", encoding="utf-8") as json_file:
    data = json.load(json_file)

# Acceder a la lista de cuentas contables desde la clave 'cuentas'
if 'response' in data and 'cuentas' in data['response']:
    cuentas_contables = data['response']['cuentas']

    # Crear el DataFrame con los datos de las cuentas contables
    df_cuentas = pd.DataFrame(cuentas_contables)

    # Mostrar el DataFrame
    print(df_cuentas)
else:
    print("No se encontraron cuentas contables o la estructura de la respuesta es diferente.")

df_cuentas

# Separar la columna 'Descripcion' por el guion y quedarte solo con la segunda parte
df_cuentas['Descripcion'] = df_cuentas['Descripcion'].str.split('-', n=1).str[1].str.strip()

# Ahora puedes realizar el merge
base_de_datos = pd.merge(df_final, df_cuentas, on='idPlanCuenta', how='left')

# Mostrar el DataFrame resultante
base_de_datos

valores_unicos = base_de_datos['idPlanCuenta'].unique()
valores_unicos

from google.colab import auth
from googleapiclient.discovery import build
import gspread
from gspread_dataframe import set_with_dataframe
import pandas as pd

# Autenticarse en Google Drive
#auth.authenticate_user()
#from google.colab import auth
#from google.auth import default

#creds, _ = default()
#gc = gspread.authorize(creds)

# Nombre del archivo y carpeta en Drive
sheet_name = "base_de_datos_real_colppy"
folder_id = "1Qg0FVctkRqsatCAXZLGpgChFjoOeVmF1"

# Conectar con Google Drive
drive_service = build('drive', 'v3', credentials=creds)
query = f"name='{sheet_name}' and mimeType='application/vnd.google-apps.spreadsheet' and '{folder_id}' in parents"
response = drive_service.files().list(q=query).execute()
files = response.get('files', [])

if files:
    # Si el archivo existe, abrirlo
    sheet = gc.open(sheet_name)
    worksheet = sheet.sheet1

    # Borrar datos previos
    worksheet.clear()

    print(f"📄 Archivo encontrado. Sobrescribiendo datos en: {sheet_name}")

else:
    # Si no existe, crearlo en la carpeta específica
    file_metadata = {
        'name': sheet_name,
        'mimeType': 'application/vnd.google-apps.spreadsheet',
        'parents': [folder_id]
    }
    file = drive_service.files().create(body=file_metadata).execute()
    sheet = gc.open_by_key(file['id'])
    worksheet = sheet.sheet1

    print(f"📄 Archivo no encontrado. Creando nuevo archivo: {sheet_name}")

# Escribir los nuevos datos en la hoja
set_with_dataframe(worksheet, base_de_datos)

print(f"✅ Datos actualizados en Google Sheets: https://docs.google.com/spreadsheets/d/{sheet.id}")